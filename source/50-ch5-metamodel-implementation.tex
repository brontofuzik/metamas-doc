%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% MASTER'S THESIS                                                            %%
%%                                                                            %% 
%% Title (en): Multi-Agent Systems and Organizations                          %%
%% Title (cs): Multiagentní systémy a organizace                              %%
%%                                                                            %%
%% Author: Bc. Lukáš Kúdela                                                   %%
%% Supervisor: Prof. RNDr. Petr Štěpánek, DrSc.                               %%
%%                                                                            %%
%% Academic year: 2011/2012                                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Metamodel Implementation---Thespian4Jade}

% Chapter - intro
In this chapter, we will present an implementation of the Thespian metamodel for the Jade agent platform---Thespian4Jade.
However, first we talk briefly about agent platforms in general and about Jade in particular. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Agent Platform}

% About agent platforms
There are numerous agent platforms available including proprietary, free/open source, and public domain software.

% General vs. specific agent plaforms
The primary distinguishing factor among them is the degree of generality.
The most general among the agent platforms do not impose any particular agent architecture and usually pick a general-purpose programming language (typically the Java programming language) as their agent programming language.
On the other hand, the least general (or more generously---most specific) agent platforms do prescribe a concrete agent architecture and generally make use of some (declarative) domain-specific language.

% Why Jade?
As our aim was to introduce organizational concepts as first-class citizens in the MAS landscape, we had to steer towards the agent platform offering the most extension points.
Therefore, we considered only the most general free and open source agent platforms.
Finally we picked the Jade platform (described in the following section) which, at the time of writing this thesis, appears to be the community choice number one.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Jade}

% Jade an agent platform and framework in one
Jade\footnote{Jade Agent Development Framework --- \url{http://jade.tilab.com/}}
is an agent platform and agent development framework in one.

% Jade as agent platform
It is a \textit{platform} because it provides a run-time environment in which the agents operate, much like a sandbox in which children play.
Jade also manages the lifetimes of the agents running on the platform, delivers messages (asynchronous message passing) and provides other services (e.g. the yellow pages service).

% Jade as a framework
Jade is also a \textit{framework} because it comes with an extensive base class libraries and the actual user-defined classes are expected to inherit from these base classes, much like a building is expected to be built within the boundaries of an already erected scaffolding.
A concrete multi-agent system is basically an instantiation of the Jade as a framework.

% About Jade
Jade simplifies the implementation of multi-agent systems by acting as a middleware that complies with the FIPA\footnote{The Foundation for Intelligent Physical Agents --- \url{http://www.fipa.org/}}
specifications\footnote{\url{http://www.fipa.org/specifications/index.html}}
and by providing a set of graphical tools that support the debugging and deployment phases.
The agent platform can be distributed across multiple machines (possibly running different operating systems) and it can be configured via a remote graphical tool.
The configuration can be even changed at run-time by moving agents from one machine to another, as and when required. 
Jade is written in the Java programming language. 

% Extensibility
Jade has been specifically designed with extensibility in mind and since our goal is to extend the multi-agent systems with organizational concepts, this is the platform of our choice.
The fact that it places great emphasis on extensibility also manifests in its choice of the actual agent programming language---the Java programming language.

% Minimalistic architecture
A feature of Jade we find particularly noteworthy is its minimalistic architecture.
Only the most fundamental services (e.g. message delivery) are hard-wired.
Whenever possible, a service is implemented as a full-fledged agent operating on the platform to whom messages can be sent (e.g. white and yellow pages service).
Even the graphical tools are only GUI front-ends to these service agents.
This minimalistic architecture is further evidence that Jade takes extensibility seriously.

% License
Jade is a free and open source software, distributed under GNU Lesser General Public License, version 2\footnote{\url{http://www.gnu.org/licenses/lgpl-2.1.html}}.
% TODO Check the spelling of "license".
The copyright holder is Telecom Italia.

% Version 
The version of Jade used in this thesis is Jade 4.1.1 released on November 18th, 2011.

% System requirements
To run Jade 4.1.1, the Java Platform, Standard Edition (Java SE) 1.4 or higher is required.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Thespian4Jade}

% Thespian4Jade - definition
Thespian4Jade is an implementation of the Thespian metamodel for the Jade platform.
It is a module extending the Jade framework with classes that can be subclassed to define platform-specific models of organizations in MASs running on the Jade platform.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{States and Parties}

% thespian4jade.behaviours
The \texttt{thespian4jade.behaviours} package contains abstractions of Jade's behaviours---interaction protocol parties and their states.
A interaction protocol party is a behaviour of a participant in an interaction protocol and a state its one of its sub-behaviours.
In order for parties to be composable, their design follows the \textit{Composite} design pattern:
\begin{itemize}
	\item \texttt{IState} plays the role of \textit{Component},
	\item concrete states play the role of \textit{Leaf} and
	\item \texttt{Party} and its subclasses play the role of \textit{Composite}.
\end{itemize}

\subsubsection{States}

% thespian4jade.behaviurs.states
The \texttt{thespian4jade.behaviurs.states} package contains classes that implement states in interaction protocol parties.

% IState, OneShotBehavioursState and FSMBehavioursState
The \texttt{IState} interface specifies a state of a party.
It declares methods that streamline registration of states and transitions in parties (FSM behaviours).

% ISenderState, OneShotBehavioursSenderState and FSMBehaviourSenderState
The \texttt{ISenderState} interface, an extension of \texttt{IState}, specifies a state in which a message is sent to all receivers using the \texttt{send(message: Message, receivers: AID[])} method.
It has two implementations:
\begin{itemize}
	\item \texttt{OneShotBehavioursSenderState} implementing a sender state that is also a Jade's one-shot behaviour and
	\item \texttt{FSMBehaviourSenderState} implementing a sender state that is also a Jade's FSM behaviour.
\end{itemize}

% IReceiverState, OneShotBehavioursReceiverState and FSMBehavioursReceiverState
The \texttt{IReceiverState} interface, an extension of \texttt{IState}, specifies a state in which a message is received from any sender using the \texttt{receive(message: Message, senders: AID[])} method.
It has two implementations:
\begin{itemize}
	\item \texttt{OneShotBehavioursReceiverState} implementing a receiver state that is also a Jade's one-shot behaviour and
	\item \texttt{FSMBehaviourReceiverState} implementing a sender state that is also a Jade's FSM behaviour.
\end{itemize}

\subsubsection*{Sender States}

% thespian4jade.behaviours.states.sender
The \texttt{thespian4jade.behaviours.states.sender} package contains, above all, the \texttt{OuterSenderState} abstract class implementing a state in which the party sends a message to the other party.
It is further specialized as:
\begin{itemize}
	\item \texttt{SingleSenderState<TMessage>} implementing a state in which only one kind of message is sent,
	\item \texttt{SendSuccessOrFailure<TMessage>} implementing a state in which two kinds of messages can be sent: one in case of success and the other one in case of failure, and 
	\item \texttt{SendAgreeOrRefuse} implementing a state in which either an \textit{agree} or \textit{refuse} message can be sent.
\end{itemize}

\subsubsection*{Receiver States}

% thespian4jade.behaviours.states.receiver
The \texttt{thespian4jade.behaviours.states.receiver} package contains the \texttt{OuterReceiverState} abstract class implementing a state in which the party receives a message from the other party.
It it further specialized by classes analogous to the sender state classes, except they receive messages instead of sending them.

\subsubsection*{Special States}

% thespian4jade.behaviours.states.special
The \texttt{thespian4jade.behaviours.states.special} package contains classes implementing some special types of states.
% StateWrapperState
The \texttt{StateWrapperState<TState>} abstract class implements a state that enables to wrap another state (or a party for that matter) that needs to be provided an argument just before its execution
\footnote{Usually because it is not yet available at the time of its creation.}
and provides a result just after its execution.
It has two specializations:
\begin{itemize}
	\item \texttt{InvokeCompetenceState<TArgument, TResult>} that wraps the \textit{Invoke competence} initiator party and
	\item \texttt{InvokeResponsibilityState<TArgument, TResult>} that wraps the \textit{Invoke responsibility} initiator party.
\end{itemize}

% EventHandler
The \texttt{EventHandler<TArgument>} abstract class is an implementation of an event-handling state that is invoked (synchronously) from the \textit{Publis event} protocol responder party.

\subsubsection{Parties}

% tehspian4jade.beahviours.parties
The \texttt{tehspian4jade.behaviours.parties} contains the \texttt{Party<TAgent>} abstract class modelling an interaction protocol party and its two specializations:
\begin{itemize}
	\item \texttt{InitiatorParty<TAgent>} representing a party that initiates an interaction and
	\item \texttt{ResponderParty<TAgent>} representing a party that responds to the initiation of others.
\end{itemize}
% IResultParty<TResult>
The \texttt{IResultParty<TResult>} interface specifies a party that produces a result, e.g. initiator parties in the \textit{Invoke competence} or \textit{Invoke responsibility} protocols.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Organization, Role and Competences}

% thespian4jade.core.organization
The \texttt{thespian4jade.core.organization} package contains classes modelling organizations and their roles with competences.

% Organization
The \texttt{Organization} abstract class---one of Thespian4Jade's three core classes---models an organization
\footnote{Actually, the \texttt{Organization} class models an organization \textit{type} and its instances model organization \textit{tokens}.}.
Since organizations in Thespian4Jade are agentified\footnote{An agentified organization has all the properties of an agent: it it autonomous and can interact (communicate) with other agents. Such an organization is an agent in its own right.}, the class is an extension of Jade's \texttt{Agent} class.
% Organization_Responder
The \texttt{Organization\_Responder} class implements an organization's responder behaviour configured to respond to the \textit{Enact role}, \textit{Deact role} and \textit{Subscribe to event} protocols.

% Concrete organization type implementation
To implement a concrete organization:
\begin{enumerate}
	\item extend the \texttt{Organization} class and
	\item override the \texttt{action()} method to add the organization's roles using the \texttt{addRole(roleClass: Class)} method.	
\end{enumerate}

% Role
The \texttt{Role} abstract class---one of Thespian4Jade's three core classes---models a role and its instances model the role's positions.
Since like organizations, roles are agentified, the class extends Jade's \texttt{Agent} class.
% Role_Responder
The \texttt{Role\_Responder} class implements a role's responder behaviour configured to respond to the \textit{Activate role}, \textit{Deactiavte role} and \textit{Invoke competence} protocols.

% Concrete role implementation
To implement a concrete role:
\begin{enumerate}
	\item extend the \texttt{Role} class and
	\item override the \texttt{action()} method to schedule the role's responder behaviour (if the role acts as a responder party in any application-logic protocol) and to add the role's competences using the \texttt{addCompetence(competenceClass: Class)} method.	
\end{enumerate}

\subsubsection{Organization Knowledge Base}

% thespian4jade.core.organization.kb
The \texttt{thespian4jade.core.organization.kb} package hold the implementation of an organization's knowledge base.
In Thespian4Jade, organizations and roles are agentified and therefore can actively gather and store knowledge about other agents (players in particular) the system.

% OrganizationKnowledgeBase
The \texttt{OrganizationKnowledgeBase} represents an organization's knowledge base.
It stores knowledge about the players enacting roles in the organization (e.g. their responsibilities).
It provides two views:
\begin{itemize}
	\item The \textit{Query} view, accessed via the \texttt{query()} method, exposing API to query the knowledge base.
	\item The \textit{Update} view, accessed via the \texttt{update()} method, exposing API to update the knowledge base.
\end{itemize}

\subsubsection{Competence}

% thespianjade.core.organization.competence
The \texttt{thespianjade.core.organization.competence} package includes classes representing role competences.
% ICompetence
The \texttt{ICompetence<TArgument, TResult>} interface models a competence with typed argument and result.
It declares two methods common to all competences:
\begin{itemize}
	\item \texttt{setArgument(argument: TArgument)} sets the argument passed to the competence and
	\item \texttt{getResult(): TResult} gets the result returned from the competence.
\end{itemize}

% Synchronous vs. asynchronous competence
A competence can be either \textit{synchronous} or \textit{asynchronous}.
Behaviours in agent-oriented programming correspond to methods in OOP, except that while the asynchronous method invocation has to be programmed explicitly in OOP, in agent-oriented programming, the asynchronous invocation of behaviours is implicit.
For example, in Jade a behaviour is invoked
\footnote{More precisely, scheduled for execution.}
by calling the \texttt{addBehaviour(behaviour: Behaviour)} method of the \texttt{Agent} class.
The method immediately returns and the invoked behaviour is executed asynchronously and concurrently with other behaviours.
If a behaviour is to be invoked synchronously from another behaviour in Jade, the calling behaviour has to \textit{include} the called behaviour as its sub-behaviour
\footnote{For example, the calling FSM behaviour includes the called behaviour as one of its states.}.
% SycnhronousCompetence
A synchronous competence is modelled by the \texttt{SynchronousCompetence<TArgument, TResult>} abstract class, a kind FSM behaviour.
To define a concrete synchronous competence, extend this class and implement the competence logic as a beahviour included as a state (or states) of this FSM behaviour.
% AsynchronousCompetence
An asynchronous competence is represented by the \texttt{AsynchronousCompetence<TArgument, TResult>} abstract class, a kind of one-shot behaviour.
To define a concrete asynchronous competence, extends this class and implement the competence logic as a behaviour invoked from the overriden \texttt{action()} method.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Player and Responsibilities}

% thespian4jade.core.player
The \texttt{thespian4jade.core.player} package contains classes modelling players with responsibilities.

% Player
The \texttt{Player} abstract class---one of Thespin4Jade three core classes---models a player
\footnote{Actually, the \texttt{Player} class models a player \textit{type} and its instances model player \textit{tokens}.}.
Since the player is basically an agent able to play roles in organizations, the class extends Jade's \texttt{Agent} class.
% PLayer_Responder
The \texttt{Player\_Responder} class implements a player's responder behaviour configured to respond to the \textit{Publish event} and \textit{Invoke responsibility} protocols.

% Concrete player implementation
To implement a concrete player:
\begin{enumerate}
	\item extend the \texttt{Player} class and
	\item override the \texttt{action()} method to add the player's responsibilities using the \texttt{addResponsibility(responsibilityClass: Class)} method.	
\end{enumerate}

The remaining classes implement a player's behaviour in all eight infrastructure protocols.
A player acts as:
\begin{itemize}
	\item an initiator party in the \textit{Enact role} protocol --- \texttt{Player\_EnactRole\_InitiatorParty},
	\item an initiator party in the \textit{Deact role} protocol --- \texttt{Player\_DeactRole\_InitiatorParty},
	\item an initiator party in the \textit{Subscribe to event} protocol --- \texttt{Player\_SubscribeToEvent\_InitiatorParty}.
	\item a responder party in the \textit{Publis event} protocol --- \texttt{Player\_PublishEvent\_ReponderParty},
	\item an initiator party in the \textit{Activate role} protocol --- \texttt{Player\_ActivateRole\_InitiatorParty},
	\item an initiator party in the \textit{Deactivate role} protocol --- \texttt{Player\_DeactivateRole\_InitiatorParty},
	\item an initiator party in the \textit{Invoke competence} protocol --- \texttt{Player\_InvokeCompetence\_InitiatorParty} and
	\item a responder party in the \textit{Invoke responsibility} protocol --- \texttt{Player\_InvokeResponsibility\_RespodnerParty}. 
\end{itemize}

\subsubsection{Player Knowledge Base}

% thespian4jade.core.player.kb
The \texttt{thespian4jade.core.player.kb} package holds the implementation of a player's knowledge base.
In Thespian4Jade, players, being agents, can actively gather and store knowledge about other agents (organizations and roles in particular) the system.

% PlayerKnowledgeBase
The \texttt{PlayerKnowledgeBase} represents a players's knowledge base.
It stores knowledge about organizations in which the player enacts roles and the enacted roles (e.g. their competences).
Like an organization's knowledge base, it also provides the \textit{Query} and \textit{Update} views.

\subsubsection{Responsibilities}

% thespian4jade.core.player.responsibility
The \texttt{thespian4jade.core.player.responsibility} package includes classes representing player responsibilities.
% IResponsibility
The \texttt{IResponsibility<TArgument, TResult>} interface models a responsibility with typed argument and result.
It prescribes two methods common to all responsibilities:
\begin{itemize}
	\item \texttt{setArgument(argument: TArgument)} sets the argument passed to the responsibility and
	\item \texttt{getResult(): TResult} gets the result returned from the responsibility.
\end{itemize}

% Synchronous vs. asynchronous responsibility
Similarly to a competence, a responsibility can be either synchronous or asynchronous, represented by the \texttt{SynchronousResponsibility<TArgument, TResult>} and \texttt{AsynchronousResponsibility<TArgument, TResult>} abstract classes.
The same that has been said about competences applies to responsibilities as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Protocols and Messages}

% thespian4jade.protocols
The \texttt{thespian4jade.protocols} package contains classes modelling protocols.
By virtue of good design, the same base classes that are used to model the application-agnostic protocols in the framework itself (between a player and an organization or role) can be used to represent the application-specific protocols in the applications using the framework (between roles within an organization). 

% Protocol - package's main class
The \texttt{Protocol} abstract class models an interaction (or communication) protocol.
Although Thespian has been designed to support protocols between more than two interacting parties, Thespian4Jade currently supports only protocols between two parties: the initiator and responder parties.
A concrete protocol must override two abstract methods (\textit{Abstract factory} design pattern):
\begin{itemize}
	\item \texttt{createInitiatorParty()} that creates a new \texttt{InitiatorParty} and
	\item \texttt{createResponderParty()} that creates a new \texttt{ResponderParty}.
\end{itemize}
Concrete protocols are singletons---they are never instantiated directly but are retrieved from the protocol registry.

% ProtocolRegistry
The \texttt{ProtocolRegistry} is a registry of protocols.
When the framework or an application needs a specific protocol, it does not instantiate the protocol class, but rather uses it as a key to retrieve that protocol's singleton from the protocol registry. 

% Protocols
The \texttt{Protocols} static class contains the keys to retrieve the infrastructure protocols from the protocol registry.
There will be an identically named static class of similar purpose in each example holding the keys to retrieve the application-logic protocols from the protocol registry. 

\subsubsection{Organization Protocols}

% thespian4jade.protocols.organization
The \texttt{thespian4jade.protocols.organization} package and its sub-packages contain classes modelling the protocols that controls the interaction between a player and an organization:
\begin{itemize}
	% thespian4jade.protocols.organization.enactrole
	\item The \texttt{EnactRoleProtocol} class models the \textit{Enact role} protocol.
	% thespian4jade.protocols.organization.deactrole
	\item The \texttt{DeactRoleProtocol} class represents the \textit{Deact role} protocol.
	% thespian4jade.protocols.organization.subscribetoevent
	\item The \texttt{SubscribeToEventProtocol} class models the \textit{Subscribe to event} protocol.
	% thespian4jade.protocols.organization.publishrole
	\item The \texttt{PublishEventProtocol} class represents the \textit{Publish event} protocol.
\end{itemize}

\subsubsection{Role Protocols}

% thespian4jade.protocols.role
The \texttt{thespian4jade.protocols.role} package and its sub-packages include classes representing the protocols that governs the communication between a player and a role (more precisely, a position) it enacts:
\begin{itemize}
	%thespian4jade.protocols.role.activaterole
	\item The \texttt{ActivateRoleProtocol} class models the \textit{Activate role} protocol.
	% thespian4jade.protocols.role.deactivaterole
	\item The \texttt{DeactivateRoleProtocol} class represents the \textit{Deactivate role} protocol.
	% thespian4jade.protocols.role.invokecompetence
	\item The \texttt{InvokeCompetenceProtocol} class models the \textit{Invoke competence} protocol.
	% thespian4jade.protocols.role.invokeresponsibility
	\item The \texttt{InvokeResponsibilityProtocol} class represents the \textit{Invoke responsibility} protocol.
\end{itemize}

\subsubsection{Messages}

% thespian4jade.language
The \texttt{thespian4jade.language} hold classes modelling messages exchanged in the protocols.
% Message - packages's main class 
The \texttt{Message} abstract class models a message with structured content; it is an abstraction over Jade's \texttt{ACLMessage} representing a message with unstructured content.
A concrete message must override two abstract methods:
\begin{itemize}
	\item \texttt{generateACLMessage(): ACLMessage} that converts this T4J message to an ACL message to be sent and
	\item \texttt{parseACLMessage(aclMessage: ACLMessage)} that converts a received ACL message to this T4J message.
\end{itemize}
% TextMessage and BinaryMessage
A message is either a \textit{text message} or a \textit{binary message} depending whether its payload (a sequence of bytes) is interpreted as a piece of text or a serializable Java object.
% TextMessage
Text messages are modelled by the \texttt{TextMessage} abstract class.
To define a concrete text message, subclass \texttt{TextMessage} and override its two abstract methods:
\begin{itemize}
	\item \texttt{generateContent(): String} that generates the content of an ACL message from this text message and
	\item \texttt{parseContent(content: String)} that parses the content of a received ACL message initializing this text message. 
\end{itemize}
% BinaryMessage
Binary messages are represented by the \texttt{BinaryMessage} abstract class.
To define a concrete binary message, extend \texttt{BinaryMessage} and override its two abstract methods:
\begin{itemize}
	\item \texttt{getContentObject(): Serializable} that gets a serializable object from this binary message to become the ACL message's \textit{content object} (payload) and
	\item \texttt{setContenObject(contentObject: Serializable)} that sets the content object of a received ACL message initializing this binary message.
\end{itemize}

% SimpleMessage
In situations where the content of a message is an unstructured piece of text, and therefore can be inserted to the message at once as opposed to built step by step using various setters, a \textit{simple message} can be used.
A simple message---a fallback to the unstructured-content approach---is modelled by the \texttt{SimpleMessage} class---a thin wrapper over Jade's \texttt{ACLMessage} class.

% IMessageFactory
The \texttt{IMessageFactory<TMessage>} is a interface for a message factory used in various receiver states to create a new message.
It follows the \textit{Abstract factory} design pattern.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Utilities}

% thespian4jade.utlities
This \texttt{thespian4jade.utilities} package contains various utility classes for general use across the whole framework.
% ClassHelper
The \texttt{ClassHelper} static class defines (static) helper methods that aid class-related reflection, most notably dynamic class instantiation.
% StringUtils
The \textit{StringUtils} static class defines (static) utility methods assisting with string manipulation performed when formulating messages.

% thespian4jade.asynchrony
This \texttt{thespian4jade.asynchrony} package includes types that support asynchrony in the framework.

% IObserver, IObservable, Observable
The \texttt{IObserver} and \texttt{IObervable} interfaces specify the Observer design pattern as employed in Thespian4Jade.
A developer can implement \texttt{IObservable} either from scratch or they can delegate the implementation to an instance of the \textit{Observable} class, which already implements the interface.
Caution has to be exercised when delegating the implementation as the original observable object has to be passed as an argument to the \texttt{notifyObservers()} method.

% Future
The \texttt{Future<T>} class models a \textit{future}
\footnote{Also called a \textit{promise} or \textit{IOU (I owe you)}.}
---an object that acts as a proxy for a initially unknown result of a yet-to-be-completed computation.
Note that a \texttt{Future<T>} is both an \texttt{IObserver} and a \texttt{IObservable}.

Although the equivalents of these types exist in Java SE standard class libraries, we have chosen to define our own lightweight versions that provide only the necessary functionality. 

% thespian4jade.example package
This \texttt{thespian4jade.example} package holds classes that extends the base classes (e.g. \texttt{Player}) with functionality that is used in all three examples, yet is not inherent to the class being extended.
% RoleEnacterPlayer
The \texttt{RoleEnacterPlayer} class models a player whose intention is to enact a predetermined role in an organization decided in advance.
% COmpetenceInvokerPlayer
The \texttt{CompetenceInvoker} class, represents a player who intends to invoke a predetermined competence. Such player is also a role-enacter since the competence has to be invoked on some role decided in advance.  